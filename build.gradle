// build.gradle

// Apply the 'java' plugin to add compilation and other Java-related tasks.
// The 'application' plugin adds tasks for running our app.
plugins {
    id 'java'
    id 'application'
    id 'com.github.johnrengelman.shadow' version '8.1.1'
    id 'org.kordamp.gradle.jandex' version '0.11.0'
}

// Specify the group and version for your project.
group 'com.example'
version '1.0-SNAPSHOT'

// Configure the Java compiler version.
java {
    sourceCompatibility = '17'
    targetCompatibility = '17'
}

// Use current Helidon 3.x version via BOM.
ext {
    helidonVersion = '3.2.3'
}

// Define where to find the libraries (dependencies) our project needs.
// 'mavenCentral()' is a very common public repository.
repositories {
    mavenCentral()
}

// Define the libraries our project depends on.
dependencies {
    implementation platform("io.helidon:helidon-bom:${helidonVersion}")
    // MP full bundle: JAX-RS, CDI, JSON-P/B, Config, Health, Metrics, OpenAPI, etc.
    implementation "io.helidon.microprofile.bundles:helidon-microprofile"

    implementation "org.bouncycastle:bcprov-jdk18on:1.78.1"
    implementation "org.bouncycastle:bcpkix-jdk18on:1.78.1"
    implementation 'io.fabric8:kubernetes-client:6.9.2'

    testImplementation "org.junit.jupiter:junit-jupiter:5.10.2"
    testImplementation "io.helidon.microprofile.tests:helidon-microprofile-tests-junit5:3.2.3"
}

// Tell the 'application' plugin where our main class is.
application {
    mainClass = 'io.helidon.microprofile.cdi.Main'
}

shadowJar {
    mergeServiceFiles() // important for CDI service descriptors
    manifest {
        attributes 'Main-Class': 'io.helidon.microprofile.cdi.Main'
    }
}

// Make sure class compilation happens before jandex, and jandex before shadowJar
tasks.named("jandex").configure {
    dependsOn(tasks.named("classes"))
}

// Ensure running the app executes jandex first so resources and service files are up to date.
tasks.named("run").configure {
    dependsOn(tasks.named("jandex"))
}

// test compilation should also wait for jandex
tasks.named("compileTestJava").configure {
    dependsOn(tasks.named("jandex"))
}

// (Optional but harmless) belt-and-suspenders for test lifecycle:
tasks.named("testClasses").configure {
    dependsOn(tasks.named("jandex"))
}

tasks.withType(Test).configureEach {
    useJUnitPlatform()
}

// Anything that reads main outputs should wait for jandex
tasks.named("shadowJar").configure {
    dependsOn(tasks.named("jandex"))
    mergeServiceFiles()
    manifest {
        attributes 'Main-Class': 'io.helidon.microprofile.cdi.Main'
    }
}

// Task: create a source archive that respects .gitignore by delegating to git archive.
// Usage: gradle gitSourceArchive
tasks.register('gitSourceArchive') {
    group = 'distribution'
    description = 'Create source tar.gz via git archive (excludes ignored files)'
    doLast {
        def git = 'git'
        def isRepo = new ByteArrayOutputStream()
        exec { commandLine git, 'rev-parse', '--is-inside-work-tree'; standardOutput = isRepo; errorOutput = new ByteArrayOutputStream(); ignoreExitValue true }
        if (!isRepo.toString().trim().equalsIgnoreCase('true')) {
            throw new GradleException('Not a git repository: cannot create source archive')
        }
        def desc
        try {
            desc = ['git','describe','--tags','--dirty','--always'].execute().text.trim()
        } catch(Exception ignored) {
            desc = null
        }
        if (!desc) {
            desc = ['git','rev-parse','--short','HEAD'].execute().text.trim()
        }
        // Actual commit object to archive (strip trailing -dirty if present)
        def objectRef = desc.replaceFirst(/-dirty$/, '')
        def outDir = file("build/distributions")
        outDir.mkdirs()
        def outFile = new File(outDir, "${project.name}-source-${desc}.tar.gz")
        println "Creating source archive ${outFile} (objectRef=${objectRef}, label=${desc})"
        exec { commandLine git, 'archive', '--format=tar.gz', '-o', outFile.absolutePath, objectRef }
        println "Created ${outFile} (${outFile.length()} bytes)"
    }
}
